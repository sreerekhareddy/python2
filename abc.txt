import os
import subprocess
import sys
import requests
import shutil
import re
import time
from pathlib import Path
from Initialization.file_handling.FileUtility import FileUtility


def run_command(command, exit_on_error=True):
    """Executes a shell command and handles errors."""
    try:
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
        print(f"Command succeeded: {command}")  # Print success message
        print(f"stdout: {result.stdout}")  # Print stdout
        print(f"stderr: {result.stderr}")  # Print stderr (even if the command is successful)
    except subprocess.CalledProcessError as e:
        print(f"Error executing {command}: {e.stderr}")  # Print stderr if command fails
        if exit_on_error:
            raise Exception(f"Command failed: {command}")  # Raise exception to propagate error



# def create_new_branch():
    # """Create a new branch."""
    # print(f"Creating new branch: {new_branch}")
    # run_command(f"{git_path} checkout -b {new_branch}")
    
def create_new_branch(new_branch):
    """Create a new branch if it doesn't exist, else checkout the existing one."""
    print(f"Checking if branch {new_branch} exists...")

    # Check if the branch exists locally or remotely
    branch_exists = False
    try:
        # List all branches (both local and remote)
        result = subprocess.run(f"{git_path} branch --all", shell=True, check=True, capture_output=True, text=True)
        if new_branch in result.stdout:
            branch_exists = True
            print(f"Branch {new_branch} exists, checking out...")
    except subprocess.CalledProcessError as e:
        print(f"Error checking for existing branches: {e.stderr}")
    
    if branch_exists:
        # Checkout to the existing branch
        run_command(f"{git_path} checkout {new_branch}")
    else:
        # Create and checkout to the new branch
        print(f"Creating new branch: {new_branch}")
        run_command(f"{git_path} checkout -b {new_branch}")


def push_new_branch():
    """Push the newly created branch to origin.""" 
    print(f"Pushing branch {new_branch} to origin...")

    # Stage the changes (add all files)
    #run_command(f"{git_path} add .")

    run_command(f'{git_path} config --global user.email "{user_email}"')
    run_command(f'{git_path} config --global user.name "{user_name}"')

    # Commit the changes
    #run_command(f'{git_path} commit -m "Merging changes and updating ApplicationComponents from submodule"')

    # Push the new branch to the remote repository
    run_command(f"{git_path} push -u origin {new_branch}")


def copy_files_from_aswsubmodule():
    """Copy all files and folders from the submodule to the current branch, excluding folders with 'RootProject'."""
    pull_number = ""
    os.chdir(asw_submodulepath)
    print(f"Current directory: {os.getcwd()}")
    print("Checking out 'PMBD-ASW-COE_RELEASE_BRANCH' branch...")
    run_command(f"{git_path} checkout {asw_branch}")
    logs = subprocess.check_output(["git", "log"]).decode("utf-8")
    pattern = r"Merge pull request #(.*?) from"
    match = re.search(pattern, logs)
    if match:
        pull_number = match.group(1)
        print(f"The first occurrence of the pull number is {pull_number}")
    else:
        print(f"Didn't find any occurrence of the pull number") 
    os.chdir("..")
    print(f"Current directory: {os.getcwd()}")
    if os.path.exists(asw_src):
        print(f"Source path exists: {asw_src}")
        if not os.path.exists(prod_asw_dest):
            os.makedirs(prod_asw_dest)
            print(f"Destination path created: {prod_asw_dest}")
        for item in os.listdir(asw_src):
            s = os.path.join(asw_src, item)
            d = os.path.join(prod_asw_dest, item)
            
            if os.path.isdir(s):
                if 'RootProject' in s:
                    print(f"Skipping directory {s} because it contains 'RootProject'")
                    continue
                if not os.path.exists(d):
                    os.makedirs(d)
                    print(f"Created directory: {d}")
                for sub_item in os.listdir(s):
                    sub_s = os.path.join(s, sub_item)
                    sub_d = os.path.join(d, sub_item)
                    
                    if os.path.isdir(sub_s):
                        if not os.path.exists(sub_d):
                            os.makedirs(sub_d)
                        for sub_sub_item in os.listdir(sub_s):
                            sub_sub_s = os.path.join(sub_s, sub_sub_item)
                            sub_sub_d = os.path.join(sub_d, sub_sub_item)
                            if os.path.isdir(sub_sub_s):
                                if not os.path.exists(sub_sub_d):
                                    os.makedirs(sub_sub_d)
                            else:
                                shutil.copy2(sub_sub_s, sub_sub_d)
                                print(f"Copied file: {sub_sub_s} to {sub_sub_d}")
                    else:
                        shutil.copy2(sub_s, sub_d)
                        print(f"Copied file: {sub_s} to {sub_d}")
            
            else:
                shutil.copy2(s, d)
                print(f"Copied file: {s} to {d}")
        
        print(f"Successfully copied all files and folders from {asw_src} to {prod_asw_dest}")
        run_command(f"{git_path} status")
        run_command(f"{git_path} add {prod_asw_dest}")
        run_command(f'{git_path} config --global user.email "{user_email}"')
        run_command(f'{git_path} config --global user.name "{user_name}"')
        run_command(f'{git_path} commit -m "Created by CI pipeline: Syncing {new_branch} ASW ARXMLs with {asw_branch} under {pull_number}"')
    else:
        print(f"Source path {asw_src} does not exist")


def copy_files_bsw():
    """Copy ARXML files from specified folders to the current branch destination, excluding folders with
    'RootProject'. """
    pull_number = ""
    os.chdir(bsw_submodulepath)
    print(f"Current directory: {os.getcwd()}")
    print("Checking out 'PMBD_BSW_RELEASE_BRANCH' branch...")
    run_command(f"{git_path} checkout {bsw_branch}")
    logs = subprocess.check_output(["git", "log"]).decode("utf-8")
    pattern = r"Merge pull request #(.*?) from"
    match = re.search(pattern, logs)
    if match:
        pull_number = match.group(1)
        print(f"The first occurrence of the pull number is {pull_number}")
    else:
        print(f"Didn't find any occurrence of the pull number") 
    os.chdir("..")
    folders_ignore = [
        ".settings", "_builds", "_log", "_metadata", "ecu_config", "ETAS_Scripts", 
        "isolar_settings", "RTESupportFile", "Tools", ".project", "algo.properties.template", 
        "EcucValueCollection_Generated.arxml", "mic_settings"
    ]
    # Get the list of all folders and files in bsw_src
    all_items = os.listdir(bsw_src)
    
    # Filter out the ignored folders and files
    items = [item for item in all_items if item not in folders_ignore]
    
    # Print the list of folders after filtering
    print(f"Folders and files to be processed: {items}")
    
    for item in items:
        src = os.path.join(bsw_src, item)
        dest = os.path.join(prod_bsw_dest, item)
        
        if os.path.exists(src):
            print(f"Source path exists: {src}")
            if not os.path.exists(dest):
                os.makedirs(dest)
                print(f"Destination path created: {dest}")
            for root, dirs, files in os.walk(src):
                if "RootProject" in root:
                    print(f"Skipping directory {root} because it contains 'RootProject'")
                    continue
                for file in files:
                    if file.endswith(".arxml"):
                        src_file = os.path.join(root, file)
                        rel_path = os.path.relpath(root, src)
                        dest_file = os.path.join(dest, rel_path, file)
                        dest_dir = os.path.dirname(dest_file)
                        if not os.path.exists(dest_dir):
                            os.makedirs(dest_dir)
                        shutil.copy2(src_file, dest_file)
                        print(f"Copied ARXML file: {src_file} to {dest_file}")
            print(f"Successfully copied ARXML files from {src} to {dest} (excluding 'RootProject' folders)")
        else:
            print(f"Source path {src} does not exist")
        
    run_command(f"{git_path} status")
    run_command(f"{git_path} add {prod_bsw_dest}")
    run_command(f'{git_path} config --global user.email "{user_email}"')
    run_command(f'{git_path} config --global user.name "{user_name}"')
    run_command(f'{git_path} commit -m "Created by CI pipeline: Syncing {new_branch} BSW ARXMLs with {bsw_branch} under {pull_number}"')


def main():
    data = f'Create_Auto_Branch_Stage~Present\n'
    FileUtility.write_text_file_with_file_mode(build_log_file_path, data, 'a')
    try:
        os.chdir(os.path.join(codepath, workspace))

        # Perform Git operations
        create_new_branch()
        
        # Copy files from submodule to current branch destination
        copy_files_from_aswsubmodule()
        
        if is_rb == "False":
            copy_files_bsw()

        # Push the new branch to the remote repository (including adding, committing, and pushing)
        push_new_branch()

        data = f'Create_Auto_Branch~Successful\n'
        FileUtility.write_text_file_with_file_mode(build_log_file_path, data, 'a')
        present_path = os.path.dirname(os.path.abspath(__file__))
        file_data = FileUtility.read_json_file(present_path + os.sep + "stage_data.json")
        file_data["stage_status"]["CreateAutoBranch"] = {"status": "Successful", "error_msg": "NA"}
        FileUtility.write_to_json_file(file_data, present_path + os.sep + "stage_data.json")

    except Exception as err:
        print(f"Exception encountered: {err}")
        data = f'Create_Auto_Branch~Failure\n'
        FileUtility.write_text_file_with_file_mode(build_log_file_path, data, 'a')
        present_path = os.path.dirname(os.path.abspath(__file__))
        file_data = FileUtility.read_json_file(present_path + os.sep + "stage_data.json")
        file_data["stage_status"]["CreateAutoBranch"] = {"status": "Failure", "error_msg": f"{err}"}
        FileUtility.write_to_json_file(file_data, present_path + os.sep + "stage_data.json")
        raise Exception(f"Failed in Create Auto Branch stage : {err}")


if __name__ == "__main__":
    new_branch = sys.argv[1]
    is_rb = sys.argv[2]
    codepath = sys.argv[3]
    workspace = sys.argv[4]
    asw_branch = sys.argv[5]
    bsw_branch = sys.argv[6]
    bsw_submodulepath = sys.argv[7]
    build_log_file_path = sys.argv[8]

    user_email = "mzptpq04@stellantis.com"
    user_name = "mzptpq04"
    git_path = "C:\\apps\\Git\\cmd\\git"
    asw_src = "PMBD-ASW-COE/FcaEPmbdArch/ApplicationComponents"
    prod_asw_dest = "FcaEPmbdArch/ApplicationComponents"
    bsw_src = "PMBD-GPEC5P-BSW/FcaEPmbdBswArch"
    prod_bsw_dest = "FcaEPmbdArch"
    asw_submodulepath = "PMBD-ASW-COE"
    

    main()
